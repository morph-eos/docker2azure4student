name: Deploy from sync bundle

on:
  push:
    branches:
      - 'sync/**'
  workflow_dispatch:
    inputs:
      sync_branch:
        description: 'sync/<timestamp>-<sha> branch to deploy'
        required: true
        type: string

permissions:
  contents: write
  id-token: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    outputs:
      sync_branch: ${{ steps.sync-branch.outputs.value }}
      image_tag: ${{ steps.manifest.outputs.image_tag }}
    concurrency:
      group: deploy-${{ github.repository }}-${{ github.event_name == 'workflow_dispatch' && github.event.inputs.sync_branch || github.ref_name }}
      cancel-in-progress: false
    env:
      TF_IN_AUTOMATION: 'true'
      TERRAFORM_WORKING_DIR: '.'
      CONTAINER_SERVICE_NAME: 'app-service'
      CONTAINER_HTTP_PORT: '80'
      CONTAINER_INTERNAL_HTTP_PORT: '8080'
      CONTAINER_HTTPS_PORT: '443'
      CONTAINER_INTERNAL_HTTPS_PORT: '8081'
      TF_VAR_environment_name: ${{ secrets.ENVIRONMENT_NAME }}
    steps:
      - name: Determine sync branch
        id: sync-branch
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ -z "${{ github.event.inputs.sync_branch }}" ]]; then
              echo "sync_branch input is required" >&2
              exit 1
            fi
            BRANCH="${{ github.event.inputs.sync_branch }}"
          else
            BRANCH="${GITHUB_REF#refs/heads/}"
          fi
          echo "value=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Checkout sync branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.sync-branch.outputs.value }}
          fetch-depth: 0

      - name: Load deployment secrets
        id: load-secrets
        run: |
          set -euo pipefail
          missing=0
          append_var() {
            local key="$1"
            local value="$2"
            local label="$3"
            local required="${4:-true}"
            if [[ -z "$value" ]]; then
              if [[ "$required" == "true" ]]; then
                echo "Missing secret: $label" >&2
                missing=1
              fi
              return
            fi
            if [[ "$value" == *$'\n'* ]]; then
              printf '%s<<__ENV__\n%s\n__ENV__\n' "$key" "$value" >> "$GITHUB_ENV"
            else
              printf '%s=%s\n' "$key" "$value" >> "$GITHUB_ENV"
            fi
          }

          append_var AZURE_CREDENTIALS_JSON "${{ secrets.AZURE_CREDENTIALS }}" AZURE_CREDENTIALS
          append_var TF_VAR_subscription_id "${{ secrets.AZURE_SUBSCRIPTION_ID }}" AZURE_SUBSCRIPTION_ID
          append_var TF_VAR_tenant_id "${{ secrets.AZURE_TENANT_ID }}" AZURE_TENANT_ID
          append_var TF_VAR_admin_ssh_public_key "${{ secrets.ADMIN_SSH_PUBLIC_KEY }}" ADMIN_SSH_PUBLIC_KEY
          append_var TF_VAR_db_admin_password "${{ secrets.DB_ADMIN_PASSWORD }}" DB_ADMIN_PASSWORD
          append_var TF_BACKEND_CONFIG "${{ secrets.TF_BACKEND_CONFIG }}" TF_BACKEND_CONFIG false
          append_var IMAGE_REGISTRY "${{ secrets.IMAGE_REGISTRY }}" IMAGE_REGISTRY
          append_var IMAGE_NAME "${{ secrets.IMAGE_NAME }}" IMAGE_NAME
          append_var REGISTRY_LOGIN_SERVER "${{ secrets.REGISTRY_LOGIN_SERVER }}" REGISTRY_LOGIN_SERVER
          append_var CONTAINER_REGISTRY_USERNAME "${{ secrets.CONTAINER_REGISTRY_USERNAME }}" CONTAINER_REGISTRY_USERNAME
          append_var CONTAINER_REGISTRY_PASSWORD "${{ secrets.CONTAINER_REGISTRY_PASSWORD }}" CONTAINER_REGISTRY_PASSWORD
          append_var VM_SSH_USERNAME "${{ secrets.VM_SSH_USERNAME }}" VM_SSH_USERNAME
          append_var VM_SSH_KEY "${{ secrets.VM_SSH_KEY }}" VM_SSH_KEY
          append_var APP_ENV_VARS_B64 "${{ secrets.APP_ENV_VARS_B64 }}" APP_ENV_VARS_B64

          if [[ $missing -ne 0 ]]; then
            exit 1
          fi
      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ env.AZURE_CREDENTIALS_JSON }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Prepare backend config (optional)
        id: backend
        run: |
          if [[ -n "$TF_BACKEND_CONFIG" ]]; then
            printf '%s\n' "$TF_BACKEND_CONFIG" > backend.hcl
            echo "args=-backend-config=backend.hcl" >> "$GITHUB_OUTPUT"
          else
            echo "args=" >> "$GITHUB_OUTPUT"
          fi

      - name: Terraform init
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: |
          terraform init -input=false ${{ steps.backend.outputs.args }}

      - name: Terraform apply
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: terraform apply -input=false -auto-approve

      - name: Extract Terraform outputs
        id: tf-outputs
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: |
          VM_IP=$(terraform output -raw vm_public_ip)
          if [[ -z "$VM_IP" ]]; then
            echo "Unable to read vm_public_ip output" >&2
            exit 1
          fi
          echo "vm_ip=$VM_IP" >> "$GITHUB_OUTPUT"

      - name: Read sync manifest
        id: manifest
        working-directory: sync-bundle
        run: |
          IMAGE_TAG=$(jq -r '.imageTag // empty' manifest.json)
          if [[ -z "$IMAGE_TAG" || "$IMAGE_TAG" == "null" ]]; then
            IMAGE_TAG=$(git rev-parse --short=12 HEAD)
          fi
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"

      - name: Docker login
        run: |
          if [[ -z "$CONTAINER_REGISTRY_USERNAME" || -z "$CONTAINER_REGISTRY_PASSWORD" ]]; then
            echo "Container registry credentials are missing" >&2
            exit 1
          fi
          echo "$CONTAINER_REGISTRY_PASSWORD" | docker login "$REGISTRY_LOGIN_SERVER" -u "$CONTAINER_REGISTRY_USERNAME" --password-stdin

      - name: Build and push container image
        id: build-push
        working-directory: sync-bundle
        env:
          IMAGE_URI: ${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.manifest.outputs.image_tag }}
        run: |
          docker build -t "$IMAGE_URI" .
          docker push "$IMAGE_URI"
          echo "image_uri=$IMAGE_URI" >> "$GITHUB_OUTPUT"

      - name: Decode application env file
        run: |
          if [[ -z "$APP_ENV_VARS_B64" ]]; then
            echo "APP_ENV_VARS_B64 secret is required" >&2
            exit 1
          fi
          echo "$APP_ENV_VARS_B64" | base64 -d > app.env

      - name: Start SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ env.VM_SSH_KEY }}

      - name: Trust VM host key
        run: ssh-keyscan -H ${{ steps.tf-outputs.outputs.vm_ip }} >> ~/.ssh/known_hosts

      - name: Copy env file to VM
        run: scp -o StrictHostKeyChecking=no app.env ${{ env.VM_SSH_USERNAME }}@${{ steps.tf-outputs.outputs.vm_ip }}:/home/${{ env.VM_SSH_USERNAME }}/app.env

      - name: Deploy container on VM
        env:
          IMAGE_URI: ${{ steps.build-push.outputs.image_uri }}
          VM_IP: ${{ steps.tf-outputs.outputs.vm_ip }}
        run: |
          ssh -o StrictHostKeyChecking=no ${{ env.VM_SSH_USERNAME }}@${VM_IP} "
            set -euo pipefail
            sudo docker login ${REGISTRY_LOGIN_SERVER} -u '${CONTAINER_REGISTRY_USERNAME}' -p '${CONTAINER_REGISTRY_PASSWORD}'
            sudo docker pull ${IMAGE_URI}
            sudo docker stop ${CONTAINER_SERVICE_NAME} || true
            sudo docker rm ${CONTAINER_SERVICE_NAME} || true
            sudo docker run -d --name ${CONTAINER_SERVICE_NAME} --env-file /home/${{ env.VM_SSH_USERNAME }}/app.env -p ${CONTAINER_HTTP_PORT}:${CONTAINER_INTERNAL_HTTP_PORT} -p ${CONTAINER_HTTPS_PORT}:${CONTAINER_INTERNAL_HTTPS_PORT} --restart unless-stopped ${IMAGE_URI}
          "

  cleanup:
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    permissions:
      contents: write
    steps:
      - name: Delete sync branch
        if: ${{ startsWith(needs.deploy.outputs.sync_branch, 'sync/') }}
        uses: actions/github-script@v7
        with:
          script: |
            const branch = '${{ needs.deploy.outputs.sync_branch }}';
            try {
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `heads/${branch}`
              });
              core.info(`Deleted sync branch ${branch}`);
            } catch (error) {
              core.warning(`Could not delete branch ${branch}: ${error.message}`);
            }
